import yaml

result = ["#pragma once"]
result.append('#include "stdafx.h"')
result.append("#include <string>")
result.append("#include <vector>")
result.append("#include <optional>")
result.append("")
result.append("/*")
result.append("")
result.append("This file was autogenerated by generate_ast_nodes.py")
result.append("")
result.append("*/")
result.append("")
result.append("struct SubAccess")
result.append("{")
result.append("\tstd::string name;")
result.append("\tSubAccess* subvar;")
result.append("\tSubAccess(std::string n, SubAccess* sa) { name = n; subvar = sa; }")
result.append("\t~SubAccess() { delete subvar; }")
result.append("};")
result.append("class Visitor;")
result.append("")
result.append("class Node { public: virtual void accept(Visitor& v) = 0; };")
result.append("class Expression : public Node {};")
result.append("class Statement : public Node {};")
result.append("")

with open("nodes.yaml") as f:
    nodes = yaml.safe_load(f)

visitables = []
for n in nodes:
	temp = ["class " + n + " : public " + nodes[n]["extends"]]
	temp.append("{")
	temp.append("public:")
	constructor = n + "("
	args = []
	initializers = []
	for i, field in enumerate(nodes[n]["fields"]):
		temp.append("\t" + field + ";")
		field_type, field_name, *_ = field.split()
		args.append(field_type + " " + field_name[0]+str(i))
		initializers.append(field_name + "(" + field_name[0]+str(i) + ")")
	constructor += ", ".join(args) + ") : " + ", ".join(initializers) + " {}"
	if "constructor-optional" in nodes[n]:
		temp.append("\t" + n + "() {}")
	temp.append("\t" + constructor)
	if not "custom-destructor" in nodes[n]:
		start_len = len(temp)
		temp.append("\t~" + n + "()")
		temp.append("\t{")
		for field in nodes[n]["fields"]:
			ftype, name, *_ = field.split()
			if "*" in ftype:
				temp.append("\t\tdelete " + name + ";")
		temp.append("\t}")
		if len(temp) == start_len + 3:
			temp.pop()
			temp.pop()
			temp.pop()
	else:
		temp.append("\t" + nodes[n]["custom-destructor"])
	if not "types" in nodes[n]:
		temp.append("\tvirtual void accept(Visitor& v);")
	result.append("\n".join(temp))
	result.append("};")
	result.append("")
	types = nodes[n].get("types", [])
	if not types:
	    visitables.append(n)
	for t in types:
		temp = ["class " + t + " : public " + n]
		temp.append("{")
		temp.append("public:")
		temp.append("\tusing " + n
                    + "::" + n + ";")
		if "not-visitable" not in nodes[n]:
			visitables.append(t)
			temp.append("\tvirtual void accept(Visitor& v);")
		temp.append("};")
		result.append("\n".join(temp) + "\n")

result.append("class Visitor {")
result.append("public:")
for v in visitables:
	result.append("\tvirtual void visit(" + v + "& x) = 0;")
result.append("};")
result.append("")
with open("nodes.h", "w") as f:
	f.write("\n".join(result))
with open("nodes.cpp", "w") as f:
	f.write('#include "stdafx.h"\n')
	f.write('#include "nodes.h"\n')
	for v in visitables:
		f.write("void " + v + "::accept(Visitor& v) { v.visit(*this); }\n")
	f.write("\n")
with open("sample_visitor.h", "w") as f:
	f.write('#include "stdafx.h"\n')
	f.write('#include "nodes.h"\n')
	f.write("class CodeGenerator : Visitor\n{\npublic:\n")
	for v in visitables:
		f.write("\tvoid visit("+v+"& b) override\n\t{\n\n\t}\n\n")
	f.write("};")