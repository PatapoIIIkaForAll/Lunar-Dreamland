#pragma once
#include "stdafx.h"
#include <string>
#include <vector>
#include <optional>

/*

This file was autogenerated by generate_ast_nodes.py

*/

struct SubAccess
{
	std::string name;
	SubAccess* subvar;
	SubAccess(std::string n, SubAccess* sa) { name = n; subvar = sa; }
	~SubAccess() { delete subvar; }
};
class Visitor;

class Node { public: virtual void accept(Visitor& v) = 0; };
class Expression : public Node {};
class Statement : public Node {};

class Block : public Node
{
public:
	std::vector<Node*> stmt_list;
	Block() {}
	Block(std::vector<Node*> s0) : stmt_list(s0) {}
	~Block() { for(Node* n: stmt_list) { delete n; } stmt_list.clear(); }
	virtual void accept(Visitor& v);
};

class ExpressionList : public Expression
{
public:
	std::optional<std::vector<Expression*>> expressions;
	ExpressionList() {}
	ExpressionList(std::optional<std::vector<Expression*>> e0) : expressions(e0) {}
	~ExpressionList() { if(expressions) { for(Expression* e: *expressions) { delete e; } } expressions->clear(); }
	virtual void accept(Visitor& v);
};

class FunctionCall : public Expression
{
public:
	std::string name;
	ExpressionList* args;
	FunctionCall(std::string n0, ExpressionList* a1) : name(n0), args(a1) {}
	~FunctionCall()
	{
		delete args;
	}
	virtual void accept(Visitor& v);
};

class ListDeclaration : public Expression
{
public:
	ExpressionList* contents;
	ListDeclaration(ExpressionList* c0) : contents(c0) {}
	~ListDeclaration()
	{
		delete contents;
	}
	virtual void accept(Visitor& v);
};

class Group : public Expression
{
public:
	Expression* content;
	Group(Expression* c0) : content(c0) {}
	~Group()
	{
		delete content;
	}
	virtual void accept(Visitor& v);
};

class ListAccess : public Expression
{
public:
	std::string name;
	Expression* index;
	SubAccess* subvar;
	ListAccess(std::string n0, Expression* i1, SubAccess* s2) : name(n0), index(i1), subvar(s2) {}
	~ListAccess()
	{
		delete index;
		delete subvar;
	}
	virtual void accept(Visitor& v);
};

class VariableAccess : public Expression
{
public:
	std::string name;
	SubAccess* subvar;
	VariableAccess(std::string n0, SubAccess* s1) : name(n0), subvar(s1) {}
	~VariableAccess()
	{
		delete subvar;
	}
	virtual void accept(Visitor& v);
};

class Value : public Expression
{
public:
	std::string value;
	Value(std::string v0) : value(v0) {}
};

class Integer : public Value
{
public:
	using Value::Value;
	virtual void accept(Visitor& v);
};

class Float : public Value
{
public:
	using Value::Value;
	virtual void accept(Visitor& v);
};

class String : public Value
{
public:
	using Value::Value;
	virtual void accept(Visitor& v);
};

class UnaryOperation : public Expression
{
public:
	Expression* right;
	UnaryOperation(Expression* r0) : right(r0) {}
	~UnaryOperation()
	{
		delete right;
	}
};

class ArithmeticNegation : public UnaryOperation
{
public:
	using UnaryOperation::UnaryOperation;
	virtual void accept(Visitor& v);
};

class LogicalNegation : public UnaryOperation
{
public:
	using UnaryOperation::UnaryOperation;
	virtual void accept(Visitor& v);
};

class BinaryOperation : public Expression
{
public:
	Expression* left;
	Expression* right;
	BinaryOperation(Expression* l0, Expression* r1) : left(l0), right(r1) {}
	~BinaryOperation()
	{
		delete left;
		delete right;
	}
};

class Addition : public BinaryOperation
{
public:
	using BinaryOperation::BinaryOperation;
	virtual void accept(Visitor& v);
};

class Subtraction : public BinaryOperation
{
public:
	using BinaryOperation::BinaryOperation;
	virtual void accept(Visitor& v);
};

class Division : public BinaryOperation
{
public:
	using BinaryOperation::BinaryOperation;
	virtual void accept(Visitor& v);
};

class Multiplication : public BinaryOperation
{
public:
	using BinaryOperation::BinaryOperation;
	virtual void accept(Visitor& v);
};

class Equal : public BinaryOperation
{
public:
	using BinaryOperation::BinaryOperation;
	virtual void accept(Visitor& v);
};

class NotEqual : public BinaryOperation
{
public:
	using BinaryOperation::BinaryOperation;
	virtual void accept(Visitor& v);
};

class LessThan : public BinaryOperation
{
public:
	using BinaryOperation::BinaryOperation;
	virtual void accept(Visitor& v);
};

class GreaterThan : public BinaryOperation
{
public:
	using BinaryOperation::BinaryOperation;
	virtual void accept(Visitor& v);
};

class LessOrEqual : public BinaryOperation
{
public:
	using BinaryOperation::BinaryOperation;
	virtual void accept(Visitor& v);
};

class GreaterOrEqual : public BinaryOperation
{
public:
	using BinaryOperation::BinaryOperation;
	virtual void accept(Visitor& v);
};

class VariableDeclaration : public Statement
{
public:
	std::string name;
	Expression* initializer;
	bool is_list;
	VariableDeclaration() {}
	VariableDeclaration(std::string n0, Expression* i1, bool i2) : name(n0), initializer(i1), is_list(i2) {}
	~VariableDeclaration()
	{
		delete initializer;
	}
	virtual void accept(Visitor& v);
};

class If : public Statement
{
public:
	Expression* condition;
	Block* if_body;
	Block* else_body;
	If(Expression* c0, Block* i1, Block* e2) : condition(c0), if_body(i1), else_body(e2) {}
	~If()
	{
		delete condition;
		delete if_body;
		delete else_body;
	}
	virtual void accept(Visitor& v);
};

class Return : public Statement
{
public:
	Expression* return_expr;
	Return() {}
	Return(Expression* r0) : return_expr(r0) {}
	~Return()
	{
		delete return_expr;
	}
	virtual void accept(Visitor& v);
};

class Output : public Statement
{
public:
	VariableAccess* left;
	Expression* right;
	Output(VariableAccess* l0, Expression* r1) : left(l0), right(r1) {}
	~Output()
	{
		delete left;
		delete right;
	}
	virtual void accept(Visitor& v);
};

class Visitor {
public:
	virtual void visit(Block& x) = 0;
	virtual void visit(ExpressionList& x) = 0;
	virtual void visit(FunctionCall& x) = 0;
	virtual void visit(ListDeclaration& x) = 0;
	virtual void visit(Group& x) = 0;
	virtual void visit(ListAccess& x) = 0;
	virtual void visit(VariableAccess& x) = 0;
	virtual void visit(Integer& x) = 0;
	virtual void visit(Float& x) = 0;
	virtual void visit(String& x) = 0;
	virtual void visit(ArithmeticNegation& x) = 0;
	virtual void visit(LogicalNegation& x) = 0;
	virtual void visit(Addition& x) = 0;
	virtual void visit(Subtraction& x) = 0;
	virtual void visit(Division& x) = 0;
	virtual void visit(Multiplication& x) = 0;
	virtual void visit(Equal& x) = 0;
	virtual void visit(NotEqual& x) = 0;
	virtual void visit(LessThan& x) = 0;
	virtual void visit(GreaterThan& x) = 0;
	virtual void visit(LessOrEqual& x) = 0;
	virtual void visit(GreaterOrEqual& x) = 0;
	virtual void visit(VariableDeclaration& x) = 0;
	virtual void visit(If& x) = 0;
	virtual void visit(Return& x) = 0;
	virtual void visit(Output& x) = 0;
};
